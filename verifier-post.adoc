:repo_url: https://github.com/spring-cloud/spring-cloud-contract/tree/master/samples

= Spring Cloud Contract

Microservice approach gives plenty of benefits but also introduces complexity. This is an inevitable result of working with distributed systems. With the increasing complexity more questions are posed. In the Spring Blog we're trying to answer them - e.g. recently we tried to tackle the problem related to  https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database[how to do zero-downtime deployment with a database]. This time we'd like to show how to test microservices and create a better API by using the Consumer Driven Contracts approach.

In order to make it easier to tackle the problem of testing microservices we are more than happy to introduce a new project in the family of Spring Cloud projects - Spring Cloud Contract. This project provides support for Consumer Driven Contracts and service schemas in Spring applications, covering a range of options for writing tests, publishing them as assets, asserting that a contract is kept by producers and consumers, for HTTP and message-based interactions.

In this article we'll describe in more depth one of the tools present under the Spring Cloud Contract project - a tool called Spring Cloud Contract Verifier (formerly known as Accurest).

Before we jump into the details let's go though some theory.

== Service providers and consumers

One of the biggest challenges related to the distributed systems is the agreement on the structure of the message. From that quite a few questions can be posed:

- Should we share code between the services?
- How should we upgrade / change the existing API?
- How can the consumer know that the server side has changed its API?
- How can the server side know that it's going to break the consumers?
- Who should create the stub of the server side for the consumer to reuse in the integration tests? How to ensure the quality of those stubs?

One of the ways to solve these problems is to introduce the notion of a "contract". A contract is an agreement between a provider and a consumer in terms of how their communication should look like. The questions remains on who should drive the change of the API, where the contract should be stored and what the contract should contain.

In this blog post we'll present the approach called "Consumer Driven Contract" approach together with the new Spring Cloud project called https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_spring_cloud_contract_verifier[Spring Cloud Contract Verifier] formerly known as Accurest and hosted by the http://codearte.io[Codearte company].

== Meanwhile in a company...

Let's imagine a following scenario:

The server side team finishes its sprint and deploys their application with a new version of the API. Since there is not much time due to tight schedules there were no consultations with the consumers of that API. The consumers mocked out the server side integrations in their tests and, since nobody has informed them, they didn't update those mocks. That's why all the tests were still green but end to end tests failed miserably. When the consumers noticed that the server side API has changed they had to invest a lot of time to adjust their production and test code in order to send and receive the new, required data. The consumer team decided that it's close to impossible to do that (due to tight schedule and complexity of the changes) so they started filing issues to the server side team to adjust their API. The server side team replies that "there is no time" and that they can "talk to their product owner so he puts that requirement into their backlog".

If you took a look at the retrospectives of both teams you could see the following.

For the consumer side:
- a breaking change was introduced and nobody informed us
- the server side team hasn't consulted their API changes - the new API is unusable
- our integration tests didn't catch the change of the server side API
- we got completely ignored by the server side team in terms of adjusting their API

For the server side:
- everybody is angry with us but we have to deliver business value
- we will not update every single consumer team's tests when we change our API

Rings a bell? Don't worry there, are ways to change this approach to make everybody less annoyed.

== What is Consumer Driven Contracts?

There a few problems presented in the aforementioned scenario:
- the API change was not consulted with the consumers
- the stubbing process is owned by the consumers thus no changes of the server side are reflected

Let's focus on the first problem. Do you remember the Test Driven Development (TDD) approach? You start with an expectation in form of a test, then you write an implementation to make the test pass and finally you refactor to make the code look nicer. "Red, green, refactor" - failing test, passing test, refactored code. TDD is about making mistakes. Mistakes related to the assumption how your code API should look like. It's an iterative process that allows you to improve the quality of your code. The developer is the driver of the change of the code's API. He is its user, he knows what he wants to achieve so he alters the API until he is happy with the results. Now, let's imagine that we move this approach to the level of design...

Since the consumers are those who use the API they should be the drivers of the API change. The main difference between that and TDD is that here you have 2 teams taking part in the process - the consumer and the server. This is where you can profit from the Consumer Driven Contract (CDC) approach. A couple of characteristics of it are:
- the server side API is designed by the consumers with collaboration of the server side team (communication is crucial!)
- the contracts are written down and have to be obliged by both parties
- the work can be decoupled - once the contracts have been noted down both teams can work independently
- the server side owns the contracts - there is a strictly defined responsibility of concrete people

As Spring Cloud team what we wanted to achieve is to have a tool that would allow us to:
- define contracts in a readable but also a flexible manner
- make the contracts show some use-cases and not only present structure of the messages
- generate tests to automatically verify the contracts against the server side
- automatically produce stubs from the contracts so that the consumers can reuse it
- make this approach possible for HTTP and messaging based communication

Spring Cloud Contract Verifier solves this problem by providing automated solutions to ensure the quality and reliability of the created contracts and their stubs. It's consisting of the following main modules:
- core part of the library gives you the concept of a Contract
- Spring Cloud Contract Verifier Maven / Gradle plugins give you the functionality of converting the Contract into tests and WireMock stubs (http://wiremock.org[WireMock is an HTTP server stub])
- Spring Cloud Contract Stub Runner allows you to automatically download stubs of the provided collaborators and starts in memory HTTP stubbed servers in your integration tests
- messaging part of Spring Cloud Contract Stub Runner allows you to send messages described in the contracts

Let's look at the following step by step example how to use the tool in case of the HTTP communication.

== CDC with Spring Cloud Contract Verifier

Let's take an example of Fraud Detection and Loan Issuance process. Let's assume that the Loan Issuance is a client to the
Fraud Detection server. Let's assume that we have to write a new feature (if a client wants too borrow too much money then
we mark him as fraud). The current implementation grants loan to everybody.

Of course both client and server development teams need to communicate directly and discuss changes while
going through the process. CDC is all about communication.

The https://github.com/spring-cloud/spring-cloud-contract/tree/master/samples/samples-standalone/http-server[server side code is available here] and https://github.com/spring-cloud/spring-cloud-contract/tree/master/samples/samples-standalone/http-client[the client side code here].

As a developer of the Loan Issuance service (a consumer to the Fraud Detection server):

- start doing TDD by writing a test to your feature
- at some point in time you need to send a request to the Fraud Detection service
- you clone the Fraud Detection service repository locally
- you define the contract locally in the repo of Fraud Detection service
- provide the group id and artifact id for the Spring Cloud Contract Stub Runner to download stubs of your collaborators
- also provide the offline work switch since you don't want to work offline
- when you need to install the stubs of the server side you execute e.g. `./mvnw clean install -DskipTests` in their repo
- when you're happy with the contract and your test passes publish a PR to the server side

As a developer of the Fraud Detection server (a server to the Loan Issuance service):

- take over the PR
- from the aforementioned Contract a test would be generated (if you try to build it your app will break cause you have a missing implementation)
- write the missing implementation
- deploy your app with the stubs e.g. `./mvnw clean deploy` you'll publish both the application fat jar and the stub jar

As a developer of the Loan Issuance service (a consumer to the Fraud Detection server):

- since the server side work was done you can merge the branch to master
- disable the offline work for Spring Cloud Contract Stub Runner
- at this moment the stubs of the server side will be automatically downloaded from Nexus / Artifactory

Code examples:

*CLIENT*

*start doing TDD*

[source,groovy,indent=0]
----
def 'should be rejected due to abnormal loan amount'() {
    given:
        LoanApplication application =
                new LoanApplication(client: new Client(id: '1234567890'), amount: 99_999)
    when:
        LoanApplicationResult loanApplication = sut.loanApplication(application)
    then:
        loanApplication.loanApplicationStatus == LoanApplicationStatus.LOAN_APPLICATION_REJECTED
        loanApplication.rejectionReason == 'Amount too high'
}
----

*at some point in time you need to send a request to the Fraud Detection service*

[source,groovy,indent=0]
----
ResponseEntity<FraudServiceResponse> response =
        restTemplate.exchange("http://localhost:" + port + "/fraudcheck", HttpMethod.PUT,
                new HttpEntity<>(request, httpHeaders),
                FraudServiceResponse.class);
----

*you define the contract locally in the repo of Fraud Detection service*

[source,groovy,indent=0]
----
package contracts

org.springframework.cloud.contract.spec.Contract.make {
				request {
				method 'PUT'
				url '/fraudcheck'
				body("""
					{
					"clientId":"${value(client(regex('[0-9]{10}')), server('1234567890'))}",
					"loanAmount":99999}
				"""
				)
				headers {
					header('Content-Type', 'application/vnd.fraud.v1+json')
				}

			}
			response {
				status 200
				body( """{
	"fraudCheckStatus": "${value(client('FRAUD'), server(regex('[A-Z]{5}')))}",
	"rejectionReason": "Amount too high"
}""")
				headers {
					 header('Content-Type': value(server(regex('application/vnd.fraud.v1.json.*')), client('application/vnd.fraud.v1+json')))
					}
			}

}
----

The Contract is written using a Groovy DSL. You might be wondering what are those `${value(client(...), server(...))}` parts. So the `${}` is a String interpolation in Groovy. You can resolve a variable inside a String. The `value(client(...), server(...))` allows you to define parts of a JSON which are dynamic. In case of an identifier or a timestamp you don't want to hardcode a value. You want to allow some different possibilities of values. That's why for the consumer side you can set regular expressions matching those values.

The aforementioned contract is an agreement between two sides that:
- if an HTTP request is sent with
    - a method `PUT` on an endpoint `/fraudcheck`
    - JSON body with `clientId` matching the regular expression `[0-9]{10}` and `loanAmount` equal to `99999`
    - and with a header `Content-Type` equal to `application/vnd.fraud.v1+json`
- then an HTTP response would be sent to the consumer that
    - has status `200`
    - contains JSON body with the `fraudCheckStatus` field contains a value `FRAUD` and the `rejectionReason` field having value `Amount too high`
    - and a `Content-Type` header with a value of `application/vnd.fraud.v1+json`

*provide the group id and artifact id for the Spring Cloud Contract Stub Runner to download stubs of your collaborators*
*also provide the offline work switch since you don't want to work offline*

[source,groovy,indent=0]
----
stubrunner:
  work-offline: true
  stubs.ids: 'com.example:http-server:+:stubs:8080'
----

*SERVER*

*take over the PR (if you try to build it your app will break cause you have a missing implementation)*

the API

[source,java,indent=0]
----
@RequestMapping(
        value = "/fraudcheck",
        method = PUT,
        consumes = FRAUD_SERVICE_JSON_VERSION_1,
        produces = FRAUD_SERVICE_JSON_VERSION_1)
public FraudCheckResult fraudCheck(@RequestBody FraudCheck fraudCheck) {
}
----

the initial impl

[source,java,indent=0]
----
@RequestMapping(
        value = "/fraudcheck",
        method = PUT,
        consumes = FRAUD_SERVICE_JSON_VERSION_1,
        produces = FRAUD_SERVICE_JSON_VERSION_1)
public FraudCheckResult fraudCheck(@RequestBody FraudCheck fraudCheck) {
    return new FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}
----

*from the aforementioned Contract a test would be generated*

[source,java,indent=0]
----
@Test
public void validate_shouldMarkClientAsFraud() throws Exception {
    // given:
        MockMvcRequestSpecification request = given()
                .header("Content-Type", "application/vnd.fraud.v1+json")
                .body("{\"clientId\":\"1234567890\",\"loanAmount\":99999}");

    // when:
        ResponseOptions response = given().spec(request)
                .put("/fraudcheck");

    // then:
        assertThat(response.statusCode()).isEqualTo(200);
        assertThat(response.header("Content-Type")).matches("application/vnd.fraud.v1.json.*");
    // and:
        DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
        assertThatJson(parsedJson).field("fraudCheckStatus").matches("[A-Z]{5}");
        assertThatJson(parsedJson).field("rejectionReason").isEqualTo("Amount too high");
}
----

As you can see all the `server()` parts of the contract that were present in the `value(client(...), server(...))` blocks got injected into the test.

*write the missing implementation*

[source,java,indent=0]
----
@RequestMapping(
        value = "/fraudcheck",
        method = PUT,
        consumes = FRAUD_SERVICE_JSON_VERSION_1,
        produces = FRAUD_SERVICE_JSON_VERSION_1)
public FraudCheckResult fraudCheck(@RequestBody FraudCheck fraudCheck) {
    if (amountGreaterThanThreshold(fraudCheck)) {
        return new FraudCheckResult(FraudCheckStatus.FRAUD, AMOUNT_TOO_HIGH);
    }
    return new FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}
----

== Summary

In this example you could see how to use the Spring Cloud Contract Verifier

== Additional Reading

- http://martinfowler.com/articles/consumerDrivenContracts.html[Consumer Driven Contracts by Ian Robinson]
- https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html[Spring Cloud Contract documentation]
- https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_spring_cloud_contract_verifier[Spring Cloud Contract Verifier documentation]
- https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/[Spring Cloud Contract Verifier Maven Plugin documentation]
